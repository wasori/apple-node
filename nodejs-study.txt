[ 남자라면 서버개발을 할 줄 알아야 한다 ]

- 프론트엔드 껍데기만으로는 웹페이지를 구현할수없다.

- 서버를 알아야 모든 서비스를 구현할 수 있다.

- 서버개발 개쉬움 겁먹지마셈

- 웹 / 앱 서비스 동작방식 :  유저 ---- 서버 ( 웹툰좀요 ----> 웹툰 줌 ) => 유저 부탁 들어주는 프로그램 ( 고깃집 알바 느낌 )

- Q. 네이버 웹툰 서버 만들기? -> 누가 a 웹툰 요청하면 a 웹툰 보내주기 코드짜면 됨 ( 이게 끝임 )

- 비슷한코드 줄이고 모듈화하고 스키마 정의하고 등등 함

- 서버개발은 복붙과 암기가 반임

=================================================================================

[ Node.js의 장점이 뭐냐면 ]

- JS는 HTML 따까리임

- 자바스크립트는 웹브라우저가 실행해줌. 브라우저에는 자바스크립트 실행 엔진이 있음 (V8)-> 이 V8을 밖으로 똑 뗀게 Node.js임

- node.js를 다른이름으로 "JavaScript 런타임" ( javascript 실행기 )

- "어 그러면 JavaScript로 일반 프로그램도 만들 수 있겠네" -> vscode 도 js & node.js 로 만든거임 ㄷㄷ

- non-blocking / 비동기 잘함 ( 성능 굿 )

- ex) 영화예매 서비스?
 
- 일반적인 서버는 먼저 온 순서대로 차례차례 처리해주는게 일반적

- 중간에 처리시간이 너무 많은 요청이 오면? 그 뒷사람은 200초 걸림 ㄷㄷ

- node.js는? 요청부터 다 받고 처리시간이 빠른 순서대로 처리해버림 => 이걸 non-blocking / 비동기처리 라고 함

- 파일 입출력, db연결과 입출력 같은건 비동기처리 중요

- 이미지변환, 동영상 압축같은 cpu를 많이 갈궈야하는 작업은 힘들어함

- 간단한요청을 많이 처리해야할때 node.js서버가 좋음

=================================================================================

[ node.js , Express 설치, 세팅 ]

- 설치 후 터미널에 npm init -y 입력 -> 막 이상한 세팅 진행될거임

- 이건 라이브러리를 설치해서 쓰기위한 세팅임 (express 라이브러리 -> 서버만들기 쉬워짐)

- 그 후 npm install express 입력

- npm은 라이브러리 설치를 도와주는 간단한 프로그램


- // express 라이브러리를 사용하겠다는 뜻
- const express = require('express')
const app = express()

app.listen(8080,() => {
    console.log('http://localhost:8080 에서 서버 실행중')
})

app.get('/',(요청, 응답) => {
    응답.send('반갑다')
})

- 코드 저장 후 터미널에 node server.js 입력

- port란?

- 컴퓨터는 다른컴퓨터와 통신하기위해 만들어짐

- 웹서비스 접속해서 이용하는 행위는 다른사람 컴퓨터에 접속하는거와 다를바없음

- 네이버, 구글에 접속하는건 네이버 컴퓨터, 구글 컴퓨터에 접속하는 행위임

- 평상시에는 다른컴퓨터에 맘대로 접속할수가없음

- 컴퓨터에 구멍을 뚫어놓으면 접속을 할수있게 만들어주는데  그 구멍을 port라고함

- 모든 컴퓨터는 포트가 6만개정도있음 ㄷㄷ 코드 중 app.listen(8080, 어쩌구가 내 컴퓨터 PORT를 오픈하는 문법임

- 누군가가 http:// IPv4 주소 : PORT번호 입력하면 내 컴퓨터로 들어올수 있음

===========================================================================

[ 웹페이지 보내주려면 ( 라우팅 ) ]

- 다른사이트들은 어떻게 하는지 구경부터 하자

- 누가 /news로 접속하면 오늘의 뉴스를 보여주자

- app.get('/URL',(요청, 응답) => {
    응답.send('데이터~~')
})

- 서버개발은 그냥 라이브러리 사용법 암기가 끝임

- 콜백함수 ( 다른함수 파라미터에 들어가는 함수 )

- 1. 누가 /shop 접속시 app.get() 함수 실행됨

- 2. 그 다음 콜백함수 실행됨

- 웹페이지를 보내주고싶으면 html파일을 보내면 됨

- html을 보내려면 응답.sendFile(__dirname + '/index.html') 라고 쓰면됨

- __dirname : server.js 담긴 폴더

=======================================================================

[ 웹페이지에 디자인 넣으려면 ]

- 서버 계속 껏다 띄웠다 너무 귀찮음 -> nodemon을 사용하면 됨

- nodemon은 파일이 수정될때마다 알아서 자동으로 실행해주는 프로그램

- 터미널 npm install -g nodemon 설치 후 nodemon server.js 실행하면 됨

- 그냥 <link>로만 하면 안되고 우선 css파일이 있는 폴더를 server.js에 등록부터 해야함

- 폴더를 server.js에 등록해두면 폴더안의 파일들을 html에서 사용가능

- server.js에 app.use(express.static(__dirname + '/public')) 입력해서 사용가능

- .css , .js .jpg 같은것들을 static파일들이라고  함 ( 변동사항이 없기때문 )

- <link href="/main.css" rel="stylesheet"> css앞에 / 붙이고 원래는 그앞에 폴더명도 쓰는데 서버에 등록해놓으면 안써야 적용됨

===============================================================================

[MongoDB 호스팅받고 세팅하기 ]

- 게시판 만든다 했을때 유저 게시물 보관을 어디에 함? =>database에 보관

- 데이터베이스는 크게 두가지로 나뉜다. 관계형데이터베이스 vs 비관계형 데이터베이스

- 관계형데이터베이스 : 엑셀과 똑같이 데이터를 저장할수있다. sql문법으로 데이터 입출력해야함. 
                 
                                     최대한 중복을 제거하려고 함 ( 정규화 )

- 데이터의 정확도가 중요하다 -> 보통 관계형 데이터베이스 사용

- 비관계형 데이터베이스 :  다양한 형식으로 데이터 저장가능 . 정규화 그런거 안함 -> 빠르게 입출력 가능

- 빠른 입출력이 필요한 서비스에 좋다 ( 게시판, sns 등등 )

- 그렇다면 정확도는 관계형 베이스 입출력빠른게 중요하면 비관계형으로 쓰면되는가? 그건 아님

- 어떻게 활용하는가에 따라 다름

- MongoDB : SQL 배울 필요 없어서 쉬움
                      
 	     귀찮은 정규화 필요없음
                       
	     테이블 정의 필요없음

 - MongoDB는 Document Database 라고도 불림	     

- 데이터를 collection(폴더)안에 document(파일)를 저장하는 방식 -> 파일을 js object 자료형식으로 저장할수있음

- 사용방법 2개 1. 컴퓨터에 직접 설치 2. 클라우드 호스팅받기

=================================================================================

[ MongoDB와 서버 연결하려면 ]

- 유저가 데이터를 저장하려할때 데이터가 정상적인지 검사가 필요함. 출력할때도 마찬가지

- 그 담당은 서버가 담당할것임. 서버가 DB랑 통신하는게 일반적

- npm install mongodb@5 입력

================================================================================

[ MongoDB에서 데이터 출력하기 ( array / object 문법 ) ]

- mongoDB에서 데이터 입력

- Q.Document 1개에 게시물 100만개 넣어둬도 될듯?

- document 너무 크면 원하는거 찾기 어려움

- document 1개는 최대 16mb

- document 1개 == 엑셀 가로줄 1개

- /list 로 방문하면 DB에서 뽑은 글들 보여주기

- app.get('/list', async (요청, 응답) => {
    let result = await db.collection('post').find().toArray();
    console.log(result);
    응답.send('DB에 있던 게시물');
})

- await라는 걸 쓰려면 async를 써야함.

- (참고) 서버에서 console.log 쓰면 터미널에 출력됨.

- await : 다음 줄 실행하지 말고 잠깐 기다려주세요 라는 뜻

- js는 참을성이 없음 -> 처리가 오래걸리는 코드는 처리완료를 기다리지 않고 바로 다음 줄 실행해버림

- await를 쓰면 기다려줌.

- await 싫으면 db.collection('post').find().toArray().then(() => {               }) 이렇게 써도 됨

- 매우 자주쓰기때문에 그냥 외우면 된다.

- " 컬렉션의 모든 document 출력하는 법 "  => await db.collection('post').find().toArray();

- ( 참고 ) await은 정해진 곳만 붙일 수 있음 ( Promise 뱉는 곳 )

- ( 참고2 ) 무슨 DB를 써도 사용방법은 다 비슷함

- Q . 첫 게시물 제목만 뽑으려면?

- 데이터 시작부분만 보면 됨 [] {}

==============================================================================

[ 웹페이지에 DB데이터 꽂기 ( EJS, 서버사이드 랜더링 ) ]

- Q. html 파일에 서버데이터 어떻게 넣음? => template engine 쓰쇼 ( EJS ) //  npm install ejs

- app.set('view engine', 'ejs') 추가

- html파일에 데이터 넣고 싶으면 .ejs 파일로 만들면 가능

- .ejs파일들은 views 폴더 안에 넣는게 국룰이라서 만들어주면됨

- .ejs파일도 그냥 .html과 똑같음. html 파일인데 서버 데이털를 집어넣을수 있다 정도

- 유저에게 ejs 파일 보내는법 : 응답.render('list.ejs')

- ( 참고 ) 응답은 1개만 가능.

- 서버 데이터를 ejs파일에 넣으려면? 2가지 스텝

- 1. ejs파일로 데이터 전송 : 응답.render('list.ejs', { posts : result })

- 2. ejs 파일 안에서 <%= 데이터 이름 %>

- html 중간에 array, object 대충 넣으면 깨짐

- <div class="list-box">
        <h4><%= posts[0].title %></h4>  -> (참고) 이런걸 서버사이드 렌더링 이라 함
        <p>글내용임</p>
      </div>

- 클라이언트 사이드 렌더링 : 빈 html 파일 + 데이터 보내고 유저 브라우저에서 html생성하기

===============================================================================

[ 여러 글을 한 번에 출력해보자 ( EJS 문법2 ) ]

- ejs파일 안에서 자바스크립트 문법 그대로 사용가능 ( 반복문, if문 )

- 여기선 <scrip></script> 이런거 없어도 됨

- 여기서 쓸때는 <% %> 안에 넣어야함

- nav바 같은것도 100개 페이지에 계속 복붙할거임? => include() 문법 사용하면 다른 ejs 파일에 있던 html 복사해올수 있음

- <%- include('??.ejs') %> ??.ejs 파일내용을 복사해옴

- <%- include('nav.ejs' , { age : 20 }) %> 이렇게 하면 변수도 보낼 수 있음

- <%- %> <%= %>차이는 = 는 html 문법이 그대로 문자로 다 출력되고 -는 그 html이 적용된 모습으로 나온다


================================================================================

[ 서버가 유저와 통신하는 법 / RESTful API ]

- server : 요청이 들어오면 그걸 처리해주는 간단한 프로그램
 
- 요청 형식을 맞춰서 보내야 제대로 처리해줌. 1.method (GET, POST 등등 ) 2. url ( /어쩌구 )

- GET : 서버에게 데이터 달라고 할때

- POST : 서버에게 데이터를 보내고 싶을때

- PUT : 서버에 데이터 수정요청할때

- DELETE: 서버에 데이터 삭제요청할때

- app.get('/news', (요청, 응답) => {
    응답.send('오늘 비옴');
})

=> 다시 뜯어보기 : 어떤 유저가 '/news' 라는 url로 get요청을 날리면 함수 안의 코드를 실행해주세요.

- app.post('/news', (요청, 응답) => {
    응답.send('오늘 비옴');
})

=> get을 post로 바꿔버리면? 어떤 유저가 '/news'라는 url로 post요청을 날리면 함수 안의 코드를 실행해주세요.
=> 이런 서버의 하나의 기능들을 API라고 부르기도 한다.

- API : 프로그램 사용법 ( 서버 기능 )

- 유저가 서버로 요청을 어떻게 하는데? 가장 쉬운 GET요청 공간 -> 웹 브라우저 주소창
- POST요청은 <form>사용하면 됨

- Q. 유저는 어떤 url, method 적어야하는지 모르는데? : 보통 웹페이지에 숨겨놓음 ( 이걸 누르면 post요청되게 등등)

- REST API : 좋은 API 디자인하는 원칙 6개

- 1. Uniform Interface ( 일관성 ) : 일관성 있는 URL 이 좋음
                                           하나의 URL + method는 하나의 데이터를 보내야 함

- 2. Client-server 구분 : 유저에게 서버 역할 맡기지 마라

- 3. Stateless : 요청끼리 서로 의존성이 있으면 안됨

- 4. Cacheability : 요청은 캐싱이 가능해야함
                                 캐싱 : 자주 수신되는 자료들은 요청을 날리지 않고 하드에 저장해놓고 씀

- 5. Layered system : 요청 하나는 최종 응답전까지 여러 단계를 거쳐도 된다.

- 6. Code on demand : 서버는 유저에게 실행가능한 코드를 보내줄 수도 잇음

- 좋은 URL 작명 관습  : 1. 동사보다는 명사 위주로
                                       2. 띄어쓰기는 언더바_대신 대시-기호
		   3. 파일 확장자 쓰지 말기 ( .html ) 이런거
 		   4. 하위 문서들을 뜻할 땐 / 기호를 사용함 ( 하위폴더 같은 느낌 )

=================================================================================

[ 글 작성기능 만들기 1( POST 요청 ) ]

- Q. 글 작성 기능어캐만듬? 

- 1. 기능이 어떤식으로 동작하는지 한글로 정리 2. 한글로 코드를 번역

- 1. 유저가 글 작성페이지에서 서버로 전송. 2. 서버는 글을 검사 3. 이상없으면 DB에 저장

- 1. 유저가 글 작성페이지에서 서버로 전송.

- <form> <input> : <form class="form-box" action = "/URL~~" method="POST">

- <input name = "title">
   <input name = "content"> form 안에 input에도 name속성이 꼭 있어야함

- 2. 서버는 글을 검사

- app.post('/add', (요청, 응답) => {
    이 코드 실행됨. 요청.body 쓰면 유저가 보낸 데이터 출력 가능 
})

- 요청.body 쓰려면 
app.use(express.json())
app.use(express.urlencoded({
    extended: true
})) => 이것들 필요함 


- 이상없으면 글을 db에 저장

==============================================================================

[ 글 작성기능 만들기2 ( insertOne, 예외 처리 ) ]

- await db.collection('post').insertOne({ title : 1 })

- 응답.redirect('/list'); 다른페이지로 이동시키기

- 유저가 빈칸으로 보내면? 리스트에 이상하게 들어가게됨. 서버에서 걸러줘야함

- if (제목이 빈칸이면) {
        DB저장하지말고 뭐 경고문 보내주고
    }else {
        await db.collection('post').insertOne({title : 요청.body.title , content : 요청.body.content})
    }

 이런식으로 해야할듯

- db에 문제가있어서 실패하고 에러메세지 나올 수가 있음

- 에러시 다른 코드 실행은 try/catch

-try {
        if (요청.body.title == '') {
            응답.send('제목 입력안했는데?');
        } else {
            await db.collection('post').insertOne({
                title: 요청.body.title,
                content: 요청.body.content
            })
            응답.redirect('/list');
        }
    } catch (e) {
        응답.status(500).send('서버에러남')
    }

- statis(500)은 서버 잘못으로 인한 에러라는 뜻으로 에러코드를 전송해주는게 좋은 관습이다.

=================================================================================

[ 상세페이지 만들기 1 ( URL parameter ) ]

- /detail/글번호 입력하면 해당 글번호가 가진 글의 상세글을 보여줌

- 글이 100개있으면? => url 파라미터 문법사용. => 비슷한 /url 가진 api 여러개 만들수있음 

- app.get('/detail/:aaaa', () => {
    
}) => "유저가 :aaaa자리에 아무 문자나 입력시"

- 모든문자가 같은페이지로 가는데? => 유저가 /detail/1로 접속하면 _id가 1인 글 내용을 ejs파일로 보내기

- 상세페이지 기능 1.유저가 /detail/어쩌구 접속하면
                             2. {_id : 어쩌구 } 글을 DB에서 찾아서
	           3. ejs 파일에 박아서 보내줌

- 유저가 글 id를 어떻게 url에 씀? => 글 제목 클릭시 이동하게 만드는 링크를 만드는거임

- 2번기능 app.get('/detail/:aaaa', async(요청, 응답) => {
   	 	await db.collection('post').findOne({a : 1}) 
    		응답.render('detail.ejs');
	})  => {} 데이터를 가진 document 1개 찾아옴

- await db.collection('post').find().toArray(); 모든 document를 가져옴

- 요청.params 쓰면 url 파라미터 자리에 들어간 문자를 알수있다

================================================================================

[ 상세페이지 만들기 2 ( 링크 만들기 ) ]

- ( 참고 ) url 파라미터는 여러개 넣어도 됨 /:123/:123

- 유저가 글 id를 어떻게 url에 씀? => 글 제목 클릭시 이동하게 만드는 링크를 만드는거임 -> <a>태그

- 서버기능을 만들었으면 예외케이스들을 처리해주는게 좋음.

- ex) 누가 url 파라미터에 이상한거적어서 접속하면 어떡할래

- 응답.status(400).send('이상한 url 입력함');

- 5xx : 서버문제 , 4xx : 유저문제

- Q. _id 길이는 맞는데 틀렸을 경우?

- try catch 만으로 잡을수 없음

- 직접 악성유저가 되어 테스트해보는게 좋음

- try {
        let result = await db.collection('post').findOne({
            _id: new ObjectId(요청.params.id)
        });
        if (result == null) {
            응답.status(404).send('이상한 url 입력함');
        }
        응답.render('detail.ejs', {
            result: result
        });
    } catch (e) {
        console.log(e);
        응답.status(404).send('이상한 url 입력함');
    }

================================================================================

[ 수정 기능 만들기 1 ]

- 게시판기능이랑 비슷함

1. 글마다 수정버튼 누르면 수정페이지로 이동한다

2. 수정페이지엔 기존 글이 채워져있다.

3. 전송누르면 입력한 내용으로 db글 수정

- document 수정하고 싶으면 updateOne()

- db.collection('post').updateOne({a : 1}, { $set : { a : 2}});

- a : 1  도큐먼트를 찾아서 a : 2 로 교체해준다

- ( 팁 ) 서버에서 정보를 찾을 수 없다면 유저에게 보내라고 하거나 / DB에서 꺼내보거나

- 전송버튼 누르면 서버로 전송, 서버는 확인 후 DB수정

- <form class="form-box" action = "/edit" method="POST">

- 수정기능은 PUT method , 삭제기능은 DELETE method 쓰는게 좋은 관습

- <form>에서는 원래 GET, POST만 가능. 굳이 PUT 쓰고싶으면 AJAX나 외부 라이브러리 사용해야함

- app.post('/edit', async (요청, 응답) => {

    await db.collection('post').updateOne({ 수정할 document 정보 }, { $set : { 수정할 내용 }});

})

- 유저가 입력칸에 적은 글들 : 요청 . body

- 직접예외처리도 해보면 좋음 (유저가 _id 이상하게 보내면? 수정할 글 내용이 없으면? 유저가 title, content말고 다른 내용으로 보내면? 이상한 에러로 수정이 실패하면? 등등 )

- (팁) 수정결과 확인가능 : result변수에 담아서 확인

-input 화면 숨기기 가능

==============================================================================

[ 수정기능 만들기 2 ( method - override, MongoDB 수정문법 추가 ) ]

- <form> 써서 PUT, DELETE 요청하는법

- 세팅이 좀 필요함 1. npm install method-override
                              2. const methodOverride = require('method-override')
	                 app.use(methodOverride('_method')) 위에 추가
	            3. <form class="form-box" action = "/edit?_method=PUT" method="POST">
                                   /요청URL 뒤에 ?_method=PUT 추가

- updateOne 추가문법 
await db.collection('post').updateOne({
        _id: 1
    }, {
        $inc: {
            like : 1
        }
    });

- $inc : like를 1올려주시오 . -2 적으면 2씩 줄어듦
- $mul : 기존값에 곱하라는 뜻
- $unset : 기존 필드값 삭제 ( 거의 안쓰니 알아만 두자 )

- Q. 동시에 여러개 document 수정?
- await db.collection('post').updateMany({
        _id: 1
    }, {
        $inc: {
            like : 1
        }
    }); => id가 1인거 전부다 적용됨

- 조건식 사용도 가능

- Q.LIKE 항목이 10이상인 document 전부 수정?

- await db.collection('post').updateMany({
        like : {$gt : 10}  ( like > 10 이라는 뜻  $gte 는 >= 이하는 $lt, $lte like != 는 $ne)
    }, {
        $inc: {
            like : 1
        }
    });